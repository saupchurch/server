"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GA4GH protocol classes, please run the script
on the appropriate schema version.
"""
from protocol import ProtocolElement
from protocol import SearchRequest
from protocol import SearchResponse

import avro.schema

version = '0.6.0a4'


class AlleleLocation(ProtocolElement):
    """
    An allele location record holds the location of an allele relative
    to a non-genomic coordinate system such as a CDS or protein and
    holds the reference and alternate sequence where appropriate
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"AlleleLocation", "fields": [{"doc": "", "type": "int", "name":
"start"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "end"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSequence"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "alternateSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateSequence', 'end', 'referenceSequence', 'start'
    ]

    def __init__(self, **kwargs):
        self.alternateSequence = kwargs.get(
            'alternateSequence', None)
        """
        Alternate sequence in feature (this should be the codon at CDS
        level)
        """
        self.end = kwargs.get(
            'end', None)
        """
        Relative end position of the allele in this coordinate system
        """
        self.referenceSequence = kwargs.get(
            'referenceSequence', None)
        """
        Reference sequence in feature (this should be the codon at CDS
        level)
        """
        self.start = kwargs.get(
            'start', None)
        """
        Relative start position of the allele in this coordinate
        system
        """


class Analysis(ProtocolElement):
    """
    An analysis contains an interpretation of one or several
    experiments. (e.g. SNVs, copy number variations, methylation
    status) together with information about the methodology used.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Analysis", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "type": ["null", "string"], "name": "name"},
{"default": null, "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"createDateTime"}, {"doc": "", "type": "string", "name":
"updateDateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "type"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "software"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "updateDateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'createDateTime', 'description', 'id', 'info', 'name',
        'software', 'type', 'updateDateTime'
    ]

    def __init__(self, **kwargs):
        self.createDateTime = kwargs.get(
            'createDateTime', None)
        """
        The time at which this record was created.    Format: :ref:ISO
        8601 <metadata_date_time>
        """
        self.description = kwargs.get(
            'description', None)
        self.id = kwargs.get(
            'id', None)
        """
        Formats of id | name | description | accessions are described
        in the   documentation on general attributes and formats.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional analysis information.
        """
        self.name = kwargs.get(
            'name', None)
        self.software = kwargs.get(
            'software', [])
        """
        The software run to generate this analysis.
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of analysis.
        """
        self.updateDateTime = kwargs.get(
            'updateDateTime', None)
        """
        The time at which this record was last updated.   Format:
        :ref:ISO 8601 <metadata_date_time>
        """


class AnalysisResult(ProtocolElement):
    """
    An AnalysisResult record holds the output of a prediction package
    such as SIFT on a specific allele.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"AnalysisResult", "fields": [{"doc": "", "type": "string", "name":
"analysisId"}, {"doc": "", "type": ["null", "string"], "name":
"result"}, {"doc": "", "type": ["null", "int"], "name": "score"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "result",
        "score",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'result', 'score'
    ]

    def __init__(self, **kwargs):
        self.analysisId = kwargs.get(
            'analysisId', None)
        """
        The ID of the analysis record for this result
        """
        self.result = kwargs.get(
            'result', None)
        """
        The text-based result for this analysis
        """
        self.score = kwargs.get(
            'score', None)
        """
        The numeric score for this analysis
        """


class Attributes(ProtocolElement):
    """
    Type defining a collection of attributes associated with various
    protocol   records.  Each attribute is a name that maps to an
    array of one or more   values.  Values can be strings, external
    identifiers, or ontology terms.   Values should be split into the
    array elements instead of using a separator   syntax that needs to
    parsed.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "term"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceVersion"}]}], "type": "array"},
"type": "map"}, "name": "vals"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'vals'
    ]

    def __init__(self, **kwargs):
        self.vals = kwargs.get(
            'vals', {})


class Call(ProtocolElement):
    """
    A Call represents the determination of genotype with respect to a
    particular Variant.  It may include associated information such as
    quality and phasing. For example, a call might assign a
    probability of 0.32 to the occurrence of a SNP named rs1234 in a
    call set with the name NA12345.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Call",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "callSetId"}, {"default": [], "doc": "", "type":
{"items": "int", "type": "array"}, "name": "genotype"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "phaseset"},
{"default": [], "doc": "", "type": {"items": "double", "type":
"array"}, "name": "genotypeLikelihood"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
        'info', 'phaseset'
    ]

    def __init__(self, **kwargs):
        self.callSetId = kwargs.get(
            'callSetId', None)
        """
        The ID of the call set this variant call belongs to.    If
        this field is not present, the ordering of the call sets from
        a   SearchCallSetsRequest over this VariantSet is guaranteed
        to match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.callSetName = kwargs.get(
            'callSetName', None)
        """
        The name of the call set this variant call belongs to.   If
        this field is not present, the ordering of the call sets from
        a   SearchCallSetsRequest over this VariantSet is guaranteed
        to match   the ordering of the calls on this Variant.   The
        number of results will also be the same.
        """
        self.genotype = kwargs.get(
            'genotype', [])
        """
        The genotype of this variant call.    A 0 value represents the
        reference allele of the associated Variant. Any   other value
        is a 1-based index into the alternate alleles of the
        associated   Variant.    If a variant had a referenceBases
        field of "T", an alternateBases   value of ["A", "C"], and the
        genotype was [2, 1], that would mean the call   represented
        the heterozygous value "CA" for this variant. If the genotype
        was instead [0, 1] the represented value would be "TA".
        Ordering of the   genotype values is important if the phaseset
        field is present.
        """
        self.genotypeLikelihood = kwargs.get(
            'genotypeLikelihood', [])
        """
        The genotype likelihoods for this variant call. Each array
        entry   represents how likely a specific genotype is for this
        call as   log10(P(data | genotype)), analogous to the GL tag
        in the VCF spec. The   value ordering is defined by the GL tag
        in the VCF spec.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant call information.
        """
        self.phaseset = kwargs.get(
            'phaseset', None)
        """
        If this field is not null, this variant call's genotype
        ordering implies   the phase of the bases and is consistent
        with any other variant calls on   the same contig which have
        the same phaseset string.
        """


class CallSet(ProtocolElement):
    """
    A CallSet is a collection of calls that were generated by the same
    analysis of the same sample.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "CallSet",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"}, {"doc":
"", "type": ["null", "string"], "name": "sampleId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"variantSetIds"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'id', 'info', 'name', 'sampleId', 'updated',
        'variantSetIds'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The date this call set was created in milliseconds from the
        epoch.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The call set ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional call set information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The call set name.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this call set's data was generated from.   Note:
        the current API does not have a rigorous definition of sample.
        Therefore, this   field actually contains an arbitrary string,
        typically corresponding to the sampleId   field in the read
        groups used to generate this call set.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this call set was last updated in
        milliseconds from the epoch.
        """
        self.variantSetIds = kwargs.get(
            'variantSetIds', [])
        """
        The IDs of the variant sets this call set has calls in.
        """


class Characterization(ProtocolElement):
    """
Read characterization data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"Characterization", "fields": [{"doc": "", "type": "string", "name":
"analysisId"}, {"doc": "", "type": "float", "name": "complexity"},
{"doc": "", "type": "float", "name": "fractionMapped"}, {"doc": "",
"type": "float", "name": "intronicFraction"}, {"doc": "", "type":
"float", "name": "exonicFraction"}, {"doc": "", "type": "float",
"name": "intergenicFraction"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "complexity",
        "exonicFraction",
        "fractionMapped",
        "intergenicFraction",
        "intronicFraction",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'complexity', 'exonicFraction', 'fractionMapped',
        'intergenicFraction', 'intronicFraction']

    def __init__(self):
        self.analysisId = None
        self.complexity = None
        self.exonicFraction = None
        self.fractionMapped = None
        self.intergenicFraction = None
        self.intronicFraction = None


class CigarOperation(object):
    """
    An enum for the different types of CIGAR alignment operations that
    exist. Used wherever CIGAR alignments are used. The different
    enumerated values have the following usage:  * ALIGNMENT_MATCH: An
    alignment match indicates that a sequence can be   aligned to the
    reference without evidence of an INDEL. Unlike the
    SEQUENCE_MATCH and SEQUENCE_MISMATCH operators, the
    ALIGNMENT_MATCH   operator does not indicate whether the reference
    and read sequences are an   exact match. This operator is
    equivalent to SAM's M. * INSERT: The insert operator indicates
    that the read contains evidence of   bases being inserted into the
    reference. This operator is equivalent to   SAM's I. * DELETE: The
    delete operator indicates that the read contains evidence of
    bases being deleted from the reference. This operator is
    equivalent to   SAM's D. * SKIP: The skip operator indicates that
    this read skips a long segment of   the reference, but the bases
    have not been deleted. This operator is   commonly used when
    working with RNA-seq data, where reads may skip long   segments of
    the reference between exons. This operator is equivalent to
    SAM's 'N'. * CLIP_SOFT: The soft clip operator indicates that
    bases at the start/end   of a read have not been considered during
    alignment. This may occur if the   majority of a read maps, except
    for low quality bases at the start/end of   a read. This operator
    is equivalent to SAM's 'S'. Bases that are soft clipped   will
    still be stored in the read. * CLIP_HARD: The hard clip operator
    indicates that bases at the start/end of   a read have been
    omitted from this alignment. This may occur if this linear
    alignment is part of a chimeric alignment, or if the read has been
    trimmed   (e.g., during error correction, or to trim poly-A tails
    for RNA-seq). This   operator is equivalent to SAM's 'H'. * PAD:
    The pad operator indicates that there is padding in an alignment.
    This operator is equivalent to SAM's 'P'. * SEQUENCE_MATCH: This
    operator indicates that this portion of the aligned   sequence
    exactly matches the reference (e.g., all bases are equal to the
    reference bases). This operator is equivalent to SAM's '='. *
    SEQUENCE_MISMATCH: This operator indicates that this portion of
    the   aligned sequence is an alignment match to the reference, but
    a sequence   mismatch (e.g., the bases are not equal to the
    reference). This can   indicate a SNP or a read error. This
    operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"


class CigarUnit(ProtocolElement):
    """
    A structure for an instance of a CIGAR operation. FIXME: This
    belongs under Reads (only readAlignment refers to this)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "operation",
        "operationLength",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'operation', 'operationLength', 'referenceSequence'
    ]

    def __init__(self, **kwargs):
        self.operation = kwargs.get(
            'operation', None)
        """
        The operation type.
        """
        self.operationLength = kwargs.get(
            'operationLength', None)
        """
        The number of bases that the operation runs for.
        """
        self.referenceSequence = kwargs.get(
            'referenceSequence', None)
        """
        referenceSequence is only used at mismatches
        (SEQUENCE_MISMATCH)   and deletions (DELETE). Filling this
        field replaces the MD tag.   If the relevant information is
        not available, leave this field as null.
        """


class Dataset(ProtocolElement):
    """
    A Dataset is a collection of related data of multiple types. Data
    providers decide how to group data into datasets. See [Metadata
    API](../api/metadata.html) for a more detailed discussion.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Dataset",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'name'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        Additional, human-readable information on the dataset.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The dataset's id, locally unique to the server instance.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the dataset.
        """


class Experiment(ProtocolElement):
    """
    An experimental preparation of a sample.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Experiment", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"doc": "", "type": "string", "name":
"createDateTime"}, {"doc": "", "type": "string", "name":
"updateDateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "runTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "molecule"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "strategy"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "selection"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"library"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryLayout"}, {"doc": "", "type": ["null", "string"],
"name": "instrumentModel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "instrumentDataFile"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "createDateTime",
        "id",
        "instrumentModel",
        "sequencingCenter",
        "updateDateTime",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'createDateTime', 'description', 'id', 'info',
        'instrumentDataFile', 'instrumentModel', 'library',
        'libraryLayout', 'molecule', 'name', 'platformUnit',
        'runTime', 'selection', 'sequencingCenter', 'strategy',
        'updateDateTime'
    ]

    def __init__(self, **kwargs):
        self.createDateTime = kwargs.get(
            'createDateTime', None)
        """
        The time at which this record was created.    Format: :ref:ISO
        8601 <metadata_date_time>
        """
        self.description = kwargs.get(
            'description', None)
        """
        A description of the experiment.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The experiment UUID. This is globally unique.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional experiment information.
        """
        self.instrumentDataFile = kwargs.get(
            'instrumentDataFile', None)
        """
        The data file generated by the instrument.   TODO: This isn't
        actually a file is it?   Should this be instrumentData
        instead?
        """
        self.instrumentModel = kwargs.get(
            'instrumentModel', None)
        """
        The instrument model used as part of this experiment.     This
        maps to sequencing technology in BAM.
        """
        self.library = kwargs.get(
            'library', None)
        """
        The name of the library used as part of this experiment.
        """
        self.libraryLayout = kwargs.get(
            'libraryLayout', None)
        """
        The configuration of sequenced reads. (e.g. Single or Paired)
        """
        self.molecule = kwargs.get(
            'molecule', None)
        """
        The molecule examined in this experiment. (e.g. genomics DNA,
        total RNA)
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the experiment.
        """
        self.platformUnit = kwargs.get(
            'platformUnit', None)
        """
        The platform unit used as part of this experiment. This is a
        flowcell-barcode   or slide unique identifier.
        """
        self.runTime = kwargs.get(
            'runTime', None)
        """
        The time at which this experiment was performed.   Granularity
        here is variable (e.g. date only).   Format: :ref:ISO 8601
        <metadata_date_time>
        """
        self.selection = kwargs.get(
            'selection', None)
        """
        The method used to enrich the target. (e.g.
        immunoprecipitation, size   fractionation, MNase digestion)
        """
        self.sequencingCenter = kwargs.get(
            'sequencingCenter', None)
        """
        The sequencing center used as part of this experiment.
        """
        self.strategy = kwargs.get(
            'strategy', None)
        """
        The experiment technique or strategy applied to the sample.
        (e.g. whole genome sequencing, RNA-seq, RIP-seq)
        """
        self.updateDateTime = kwargs.get(
            'updateDateTime', None)
        """
        The time at which this record was last updated.   Format:
        :ref:ISO 8601 <metadata_date_time>
        """


class ExternalIdentifier(ProtocolElement):
    """
    Identifier from a public database
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "database",
        "identifier",
        "version",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'database', 'identifier', 'version'
    ]

    def __init__(self, **kwargs):
        self.database = kwargs.get(
            'database', None)
        """
        The source of the identifier.   (e.g. Ensembl)
        """
        self.identifier = kwargs.get(
            'identifier', None)
        """
        The ID defined by the external database.   (e.g.
        ENST00000000000)
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the object or the database   (e.g. 78)
        """


class Feature(ProtocolElement):
    """
    Node in the annotation graph that annotates a contiguous region of
    a   sequence.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Feature",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "parentId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "childIds"},
{"doc": "", "type": "string", "name": "featureSetId"}, {"doc": "",
"type": "string", "name": "referenceName"}, {"default": 0, "doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"end"}, {"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"],
"doc": "", "type": "enum", "name": "Strand"}, "name": "strand"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "term"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceVersion"}]}, "name":
"featureType"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "Attributes", "fields": [{"default": {}, "type": {"values":
{"items": ["string", {"doc": "", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}]}, "OntologyTerm"],
"type": "array"}, "type": "map"}, "name": "vals"}]}, "name":
"attributes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "end",
        "featureSetId",
        "featureType",
        "id",
        "parentId",
        "referenceName",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'childIds', 'end', 'featureSetId',
        'featureType', 'id', 'parentId', 'referenceName', 'start',
        'strand'
    ]

    def __init__(self, **kwargs):
        self.attributes = kwargs.get(
            'attributes', None)
        """
        Name/value attributes of the annotation.  Attribute names
        follow the GFF3     naming convention of reserved names
        starting with an upper cases     character, and user-define
        names start with lower-case.  Most GFF3     pre-defined
        attributes apply, the exceptions are ID and Parent, which are
        defined as fields. Additional, the following attributes are
        added:     * Score - the GFF3 score column     * Phase - the
        GFF3 phase column for CDS features.
        """
        self.childIds = kwargs.get(
            'childIds', [])
        """
        Ordered array of Child Ids of this node.     Since not all
        child nodes are ordered by genomic coordinates,     this can't
        always be reconstructed from parentId's of the children alone.
        """
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.     This is typically calculated by
        start + referenceBases.length.
        """
        self.featureSetId = kwargs.get(
            'featureSetId', None)
        """
        Identifier for the containing feature set.
        """
        self.featureType = kwargs.get(
            'featureType', None)
        """
        Feature that is annotated by this region.  Normally, this will
        be a term in     the Sequence Ontology.
        """
        self.id = kwargs.get(
            'id', None)
        """
        Id of this annotation node.
        """
        self.parentId = kwargs.get(
            'parentId', None)
        """
        Parent Id of this node. Set to empty string if node has no
        parent.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this feature occurs.     (e.g. chr20 or
        X)
        """
        self.start = kwargs.get(
            'start', 0)
        """
        The start position at which this feature occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.     Genomic positions are non-negative integers less
        than reference length.     Features spanning the join of
        circular genomes are represented as     two features one on
        each side of the join (position 0).
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        The strand on which the feature is present.
        """


class FeatureSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'info', 'name', 'referenceSetId',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this annotation set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of this annotation set.
        """
        self.info = kwargs.get(
            'info', {})
        """
        Remaining structured metadata key-value pairs.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The display name for this annotation set.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ID of the reference set which defines the coordinate-space
        for this     set of annotations.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The source URI describing the file from which this annotation
        set was     generated, if any.
        """


class GAException(ProtocolElement):
    """
    A general exception type.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "error", "name":
"GAException", "fields": [{"doc": "", "type": "string", "name":
"message"}, {"default": -1, "doc": "", "type": "int", "name":
"errorCode"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "message",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'errorCode', 'message'
    ]

    def __init__(self, **kwargs):
        self.errorCode = kwargs.get(
            'errorCode', -1)
        """
        The numerical error code
        """
        self.message = kwargs.get(
            'message', None)
        """
        The error message
        """


class HGVSAnnotation(ProtocolElement):
    """
    A HGVSAnnotation record holds Human Genome Variation Society
    descriptions of the sequence change with respect to genomic,
    transcript and protein sequences. See:
    http://www.hgvs.org/mutnomen/recs.html. Descriptions should be
    provided at genomic level. Descriptions at transcript level should
    be provided when the allele lies within a transcript. Descriptions
    at protein level should be provided when the allele lies within
    the translated sequence or stop codon.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"HGVSAnnotation", "fields": [{"default": null, "type": ["null",
"string"], "name": "genomic"}, {"default": null, "type": ["null",
"string"], "name": "transcript"}, {"default": null, "type": ["null",
"string"], "name": "protein"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'genomic', 'protein', 'transcript'
    ]

    def __init__(self, **kwargs):
        self.genomic = kwargs.get(
            'genomic', None)
        self.protein = kwargs.get(
            'protein', None)
        self.transcript = kwargs.get(
            'transcript', None)


class LinearAlignment(ProtocolElement):
    """
    A linear alignment describes the alignment of a read to a
    Reference, using a position and CIGAR array.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"doc": "", "type": "string",
"name": "referenceName"}, {"doc": "", "type": "long", "name":
"position"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'position'
    ]

    def __init__(self, **kwargs):
        self.cigar = kwargs.get(
            'cigar', [])
        """
        Represents the local alignment of this sequence (alignment
        matches, indels, etc)   versus the reference.
        """
        self.mappingQuality = kwargs.get(
            'mappingQuality', None)
        """
        The mapping quality of this alignment, meaning the likelihood
        that the read   maps to this position.    Specifically, this
        is -10 log10 Pr(mapping position is wrong), rounded to the
        nearest integer.
        """
        self.position = kwargs.get(
            'position', None)
        """
        The position of this alignment.
        """


class ListReferenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to GET /references/{id}/bases,
    for example:  GET /references/{id}/bases?start=100&end=200
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query. Defaults
        to the length of this Reference.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.start = kwargs.get(
            'start', 0)
        """
        The start position (0-based) of this query. Defaults to 0.
        Genomic positions are non-negative integers less than
        reference length.   Requests spanning the join of circular
        genomes are represented as   two requests one on each side of
        the join (position 0).
        """


class ListReferenceBasesResponse(ProtocolElement):
    """
    The response from GET /references/{id}/bases expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.offset = kwargs.get(
            'offset', 0)
        """
        The offset position (0-based) of the given sequence from the
        start of this   Reference. This value will differ for each
        page in a paginated request.
        """
        self.sequence = kwargs.get(
            'sequence', None)
        """
        A substring of the bases that make up this reference. Bases
        are represented   as IUPAC-IUB codes; this string matches the
        regexp [ACGTMRWSYKVHDBN]*.
        """


class OntologyTerm(ProtocolElement):
    """
    An ontology term describing an attribute. (e.g. the phenotype
    attribute   'polydactyly' from HPO)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "term"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceVersion"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'sourceName', 'sourceVersion', 'term'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        Ontology source identifier - the identifier, a CURIE
        (preferred) or   PURL for an ontology source e.g.
        http://purl.obolibrary.org/obo/hp.obo   It differs from the
        standard GA4GH schema's :ref:id <apidesign_object_ids>   in
        that it is a URI pointing to an information resource outside
        of the scope   of the schema or its resource implementation.
        """
        self.sourceName = kwargs.get(
            'sourceName', None)
        """
        Ontology source name - the name of ontology from which the
        term is obtained   e.g. 'Human Phenotype Ontology'
        """
        self.sourceVersion = kwargs.get(
            'sourceVersion', None)
        """
        Ontology source version - the version of the ontology from
        which the   OntologyTerm is obtained; e.g. 2.6.1.   There is
        no standard for ontology versioning and some frequently
        released ontologies may use a datestamp, or build number.
        """
        self.term = kwargs.get(
            'term', None)
        """
        Ontology term - the representation the id is pointing to.
        """


class Position(ProtocolElement):
    """
    A Position is an unoriented base in some Reference. A Position is
    represented by a Reference name, and a base number on that
    Reference (0-based).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Position", "fields": [{"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "referenceName",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'position', 'referenceName', 'strand'
    ]

    def __init__(self, **kwargs):
        self.position = kwargs.get(
            'position', None)
        """
        The 0-based offset from the start of the forward strand for
        that Reference.   Genomic positions are non-negative integers
        less than Reference length.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The name of the Reference on which the Position is located.
        """
        self.strand = kwargs.get(
            'strand', None)
        """
        Strand the position is associated with.
        """


class Program(ProtocolElement):
    """
    Program can be used to track the provenance of how read data was
    generated.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Program",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'commandLine', 'id', 'name', 'prevProgramId', 'version'
    ]

    def __init__(self, **kwargs):
        self.commandLine = kwargs.get(
            'commandLine', None)
        """
        The command line used to run this program.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The user specified ID of the program.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of the program.
        """
        self.prevProgramId = kwargs.get(
            'prevProgramId', None)
        """
        The ID of the program run before this one.
        """
        self.version = kwargs.get(
            'version', None)
        """
        The version of the program run.
        """


class ReadAlignment(ProtocolElement):
    """
    Each read alignment describes an alignment with additional
    information about the fragment and the read. A read alignment
    object is equivalent to a line in a SAM file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentName"}, {"default":
null, "doc": "", "type": ["null", "boolean"], "name":
"improperPlacement"}, {"default": null, "doc": "", "type": ["null",
"boolean"], "name": "duplicateFragment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "numberReads"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "fragmentLength"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"readNumber"}, {"default": null, "doc": "", "type": ["null",
"boolean"], "name": "failedVendorQualityChecks"}, {"default": null,
"doc": "", "type": ["null", {"doc": "", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"doc": "", "type": "string",
"name": "referenceName"}, {"doc": "", "type": "long", "name":
"position"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}]}], "name": "alignment"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name": "secondaryAlignment"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Position"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "fragmentName",
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedQuality', 'alignedSequence', 'alignment',
        'duplicateFragment', 'failedVendorQualityChecks',
        'fragmentLength', 'fragmentName', 'id', 'improperPlacement',
        'info', 'nextMatePosition', 'numberReads', 'readGroupId',
        'readNumber', 'secondaryAlignment', 'supplementaryAlignment'
    ]

    def __init__(self, **kwargs):
        self.alignedQuality = kwargs.get(
            'alignedQuality', [])
        """
        The quality of the read sequence contained in this alignment
        record   (equivalent to QUAL in SAM).    alignedSequence and
        alignedQuality may be shorter than the full read sequence
        and quality. This will occur if the alignment is part of a
        chimeric alignment,   or if the read was trimmed. When this
        occurs, the CIGAR for this read will   begin/end with a hard
        clip operator that will indicate the length of the excised
        sequence.
        """
        self.alignedSequence = kwargs.get(
            'alignedSequence', None)
        """
        The bases of the read sequence contained in this alignment
        record (equivalent   to SEQ in SAM).    alignedSequence and
        alignedQuality may be shorter than the full read sequence
        and quality. This will occur if the alignment is part of a
        chimeric alignment,   or if the read was trimmed. When this
        occurs, the CIGAR for this read will   begin/end with a hard
        clip operator that will indicate the length of the   excised
        sequence.
        """
        self.alignment = kwargs.get(
            'alignment', None)
        """
        The alignment for this alignment record. This field will be
        null if the read   is unmapped.
        """
        self.duplicateFragment = kwargs.get(
            'duplicateFragment', None)
        """
        The fragment is a PCR or optical duplicate (SAM flag 0x400).
        """
        self.failedVendorQualityChecks = kwargs.get(
            'failedVendorQualityChecks', None)
        """
        The read fails platform or vendor quality checks (SAM flag
        0x200).
        """
        self.fragmentLength = kwargs.get(
            'fragmentLength', None)
        """
        The observed length of the fragment, equivalent to TLEN in
        SAM.
        """
        self.fragmentName = kwargs.get(
            'fragmentName', None)
        """
        The fragment name. Equivalent to QNAME (query template name)
        in SAM.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read alignment ID. This ID is unique within the read group
        this   alignment belongs to.    For performance reasons, this
        field may be omitted by a backend.   If provided, its intended
        use is to make caching and UI display easier for   genome
        browsers and other lightweight clients.
        """
        self.improperPlacement = kwargs.get(
            'improperPlacement', None)
        """
        The orientation and the distance between reads from the
        fragment are   inconsistent with the sequencing protocol
        (inverse of SAM flag 0x2)
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read alignment information.
        """
        self.nextMatePosition = kwargs.get(
            'nextMatePosition', None)
        """
        The mapping of the primary alignment of the
        (readNumber+1)%numberReads   read in the fragment. It replaces
        mate position and mate strand in SAM.
        """
        self.numberReads = kwargs.get(
            'numberReads', None)
        """
        The number of reads in the fragment (extension to SAM flag
        0x1)
        """
        self.readGroupId = kwargs.get(
            'readGroupId', None)
        """
        The ID of the read group this read belongs to.   (Every read
        must belong to exactly one read group.)
        """
        self.readNumber = kwargs.get(
            'readNumber', None)
        """
        The read ordinal in the fragment, 0-based and less than
        numberReads. This   field replaces SAM flag 0x40 and 0x80 and
        is intended to more cleanly   represent multiple reads per
        fragment.
        """
        self.secondaryAlignment = kwargs.get(
            'secondaryAlignment', None)
        """
        Whether this alignment is secondary. Equivalent to SAM flag
        0x100.   A secondary alignment represents an alternative to
        the primary alignment   for this read. Aligners may return
        secondary alignments if a read can map   ambiguously to
        multiple coordinates in the genome.    By convention, each
        read has one and only one alignment where both
        secondaryAlignment and supplementaryAlignment are false.
        """
        self.supplementaryAlignment = kwargs.get(
            'supplementaryAlignment', None)
        """
        Whether this alignment is supplementary. Equivalent to SAM
        flag 0x800.   Supplementary alignments are used in the
        representation of a chimeric   alignment. In a chimeric
        alignment, a read is split into multiple   linear alignments
        that map to different reference contigs. The first   linear
        alignment in the read will be designated as the representative
        alignment;   the remaining linear alignments will be
        designated as supplementary alignments.   These alignments may
        have different mapping quality scores.    In each linear
        alignment in a chimeric alignment, the read will be hard
        clipped.   The alignedSequence and alignedQuality fields in
        the alignment record will   only represent the bases for its
        respective linear alignment.
        """


class ReadGroup(ProtocolElement):
    """
    A ReadGroup is a set of reads derived from one physical sequencing
    process.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": ["null",
"string"], "name": "sampleId"}, {"doc": "", "type": ["null", {"doc":
"", "type": "record", "name": "Experiment", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": "string", "name": "createDateTime"}, {"doc": "", "type":
"string", "name": "updateDateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null", {"doc": "",
"type": "record", "name": "ReadStats", "fields": [{"default": null,
"doc": "", "type": ["null", "long"], "name": "alignedReadCount"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"unalignedReadCount"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "baseCount"}]}], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"Program", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "commandLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}]}, "type": "array"}, "name": "programs"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceSetId"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "experiment",
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'datasetId', 'description', 'experiment', 'id',
        'info', 'name', 'predictedInsertSize', 'programs',
        'referenceSetId', 'sampleId', 'stats', 'updated'
    ]

    def __init__(self, **kwargs):
        self.created = kwargs.get(
            'created', None)
        """
        The time at which this read group was created in milliseconds
        from the epoch.
        """
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group belongs to.
        """
        self.description = kwargs.get(
            'description', None)
        """
        The read group description.
        """
        self.experiment = kwargs.get(
            'experiment', None)
        """
        The experiment used to generate this read group.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional read group information.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group name.
        """
        self.predictedInsertSize = kwargs.get(
            'predictedInsertSize', None)
        """
        The predicted insert size of this read group.
        """
        self.programs = kwargs.get(
            'programs', [])
        """
        The programs used to generate this read group.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ID of the reference set to which the reads in this read
        group are aligned.   Required if there are any read
        alignments.
        """
        self.sampleId = kwargs.get(
            'sampleId', None)
        """
        The sample this read group's data was generated from.   Note:
        the current API does not have a rigorous definition of sample.
        Therefore, this   field actually contains an arbitrary string,
        typically corresponding to the SM tag in a   BAM file.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group.
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this read group was last updated in
        milliseconds   from the epoch.
        """


class ReadGroupSet(ProtocolElement):
    """
    A ReadGroupSet is a logical collection of ReadGroups. Typically
    one ReadGroupSet represents all the reads from one experimental
    sample.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroupSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ReadStats", "fields":
[{"default": null, "doc": "", "type": ["null", "long"], "name":
"alignedReadCount"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "unalignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "baseCount"}]}], "name": "stats"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "ReadGroup", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"doc": "", "type": "record", "name": "Experiment", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}, {"doc":
"", "type": "string", "name": "createDateTime"}, {"doc": "", "type":
"string", "name": "updateDateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "Program", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}]}, "type": "array"}, "name":
"readGroups"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'name', 'readGroups', 'stats'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this read group set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The read group set ID.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The read group set name.
        """
        self.readGroups = kwargs.get(
            'readGroups', [])
        """
        The read groups in this set.
        """
        self.stats = kwargs.get(
            'stats', None)
        """
        Statistical data on reads in this read group set.
        """


class ReadStats(ProtocolElement):
    """
    ReadStats can be used to provide summary statistics about read
    data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadStats", "fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedReadCount', 'baseCount', 'unalignedReadCount'
    ]

    def __init__(self, **kwargs):
        self.alignedReadCount = kwargs.get(
            'alignedReadCount', None)
        """
        The number of aligned reads.
        """
        self.baseCount = kwargs.get(
            'baseCount', None)
        """
        The total number of bases.   This is equivalent to the sum of
        alignedSequence.length for all reads.
        """
        self.unalignedReadCount = kwargs.get(
            'unalignedReadCount', None)
        """
        The number of unaligned reads.
        """


class Reference(ProtocolElement):
    """
    A Reference is a canonical assembled contig, intended to act as a
    reference coordinate space for other genomic annotations. A single
    Reference might represent the human chromosome 1, for instance.
    References are designed to be immutable.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Reference", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "long", "name": "length"}, {"doc": "", "type":
"string", "name": "md5checksum"}, {"doc": "", "type": "string",
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceURI"}, {"doc": "", "type": {"items":
"string", "type": "array"}, "name": "sourceAccessions"}, {"default":
false, "doc": "", "type": "boolean", "name": "isDerived"}, {"default":
null, "doc": "", "type": ["null", "float"], "name":
"sourceDivergence"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "ncbiTaxonId"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
        "md5checksum",
        "name",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'isDerived', 'length', 'md5checksum', 'name',
        'ncbiTaxonId', 'sourceAccessions', 'sourceDivergence',
        'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.id = kwargs.get(
            'id', None)
        """
        The reference ID. Unique within the repository.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A sequence X is said to be derived from source sequence Y, if
        X and Y   are of the same length and the per-base sequence
        divergence at A/C/G/T bases   is sufficiently small. Two
        sequences derived from the same official   sequence share the
        same coordinates and annotations, and   can be replaced with
        the official sequence for certain use cases.
        """
        self.length = kwargs.get(
            'length', None)
        """
        The length of this reference's sequence.
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        The MD5 checksum uniquely representing this Reference as a
        lower-case   hexadecimal string, calculated as the MD5 of the
        upper-case sequence   excluding all whitespace characters
        (this is equivalent to SQ:M5 in SAM).
        """
        self.name = kwargs.get(
            'name', None)
        """
        The name of this reference. (e.g. '22').
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human).
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) which must include   a version number, e.g.
        GCF_000001405.26.
        """
        self.sourceDivergence = kwargs.get(
            'sourceDivergence', None)
        """
        The sourceDivergence is the fraction of non-indel bases that
        do not match the   reference this record was derived from.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        The URI from which the sequence was obtained. Specifies a
        FASTA format   file/string with one name, sequence pair. In
        most cases, clients should call   the getReferenceBases()
        method to obtain sequence bases for a Reference   instead of
        attempting to retrieve this URI.
        """


class ReferenceSet(ProtocolElement):
    """
    A ReferenceSet is a set of References which typically comprise a
    reference assembly, such as GRCh38. A ReferenceSet defines a
    common coordinate space for comparing reference-aligned
    experimental data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReferenceSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": "string", "name": "md5checksum"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "md5checksum",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'assemblyId', 'description', 'id', 'isDerived', 'md5checksum',
        'name', 'ncbiTaxonId', 'sourceAccessions', 'sourceURI'
    ]

    def __init__(self, **kwargs):
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        Public id of this reference set, such as GRCh37.
        """
        self.description = kwargs.get(
            'description', None)
        """
        Optional free text description of this reference set.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The reference set ID. Unique in the repository.
        """
        self.isDerived = kwargs.get(
            'isDerived', False)
        """
        A reference set may be derived from a source if it contains
        additional sequences, or some of the sequences within it are
        derived   (see the definition of isDerived in Reference).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        Order-independent MD5 checksum which identifies this
        ReferenceSet.    To compute this checksum, make a list of
        Reference.md5checksum for all   References in this set. Then
        sort that list, and take the MD5 hash of   all the strings
        concatenated together. Express the hash as a lower-case
        hexadecimal string.
        """
        self.name = kwargs.get(
            'name', None)
        """
        The reference set name.
        """
        self.ncbiTaxonId = kwargs.get(
            'ncbiTaxonId', None)
        """
        ID from http://www.ncbi.nlm.nih.gov/taxonomy (e.g.
        9606->human) indicating   the species which this assembly is
        intended to model. Note that contained   References may
        specify a different ncbiTaxonId, as assemblies may   contain
        reference sequences which do not belong to the modeled
        species, e.g.   EBV in a human reference genome.
        """
        self.sourceAccessions = kwargs.get(
            'sourceAccessions', None)
        """
        All known corresponding accession IDs in INSDC
        (GenBank/ENA/DDBJ) ideally   with a version number, e.g.
        NC_000001.11.
        """
        self.sourceURI = kwargs.get(
            'sourceURI', None)
        """
        Specifies a FASTA format file/string.
        """


class SearchCallSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /callsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.name = kwargs.get(
            'name', None)
        """
        Only return call sets with this name (case-sensitive, exact
        match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchCallSetsResponse(SearchResponse):
    """
    This is the response from POST /callsets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "CallSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "variantSetIds"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "callSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.callSets = kwargs.get(
            'callSets', [])
        """
        The list of matching call sets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchDatasetsRequest(SearchRequest):
    """
    This request maps to the body of POST /datasets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchDatasetsResponse(SearchResponse):
    """
    This is the response from POST /datasets/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Dataset", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}, "type": "array"},
"name": "datasets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.datasets = kwargs.get(
            'datasets', [])
        """
        The list of datasets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchFeatureSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /featuresets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeatureSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The Dataset to search.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.     If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     To get the next page of results, set this
        parameter to the value of     nextPageToken from the previous
        response.
        """


class SearchFeatureSetsResponse(SearchResponse):
    """
    This is the response from POST /featuresets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeatureSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "FeatureSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "featureSets"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "featureSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureSets': FeatureSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureSets': FeatureSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'featureSets', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.featureSets = kwargs.get(
            'featureSets', [])
        """
        The list of matching feature sets.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     Provide this value in a subsequent request to
        return the next page of     results. This field will be empty
        if there aren't any additional results.
        """


class SearchFeaturesRequest(SearchRequest):
    """
    This request maps to the body of POST /features/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesRequest", "fields": [{"doc": "", "type": ["null",
"string"], "name": "featureSetId"}, {"doc": "", "type": ["null",
"string"], "name": "parentId"}, {"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "start"},
{"doc": "", "type": "long", "name": "end"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "featureTypes"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "featureSetId",
        "parentId",
        "referenceName",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'featureSetId', 'featureTypes', 'pageSize',
        'pageToken', 'parentId', 'referenceName', 'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        overlapping     features should be returned.
        """
        self.featureSetId = kwargs.get(
            'featureSetId', None)
        """
        The annotation set to search within. Either featureSetId or
        parentId must be non-empty.
        """
        self.featureTypes = kwargs.get(
            'featureTypes', [])
        """
        If specified, this query matches only annotations whose
        featureType     matches one of the provided ontology terms.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.     If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     To get the next page of results, set this
        parameter to the value of     nextPageToken from the previous
        response.
        """
        self.parentId = kwargs.get(
            'parentId', None)
        """
        Restricts the search to direct children of the given parent
        feature     ID. Either featureSetId or parentId must be non-
        empty.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Only return features on the reference with this name
        (matched to literal reference name as imported from the GFF3).
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which     overlapping features should be returned.  Genomic
        positions are     non-negative integers less than reference
        length.  Requests spanning the     join of circular genomes
        are represented as two requests one on each side     of the
        join (position 0).
        """


class SearchFeaturesResponse(SearchResponse):
    """
    This is the response from POST /features/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Feature", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "parentId"}, {"default":
[], "doc": "", "type": {"items": "string", "type": "array"}, "name":
"childIds"}, {"doc": "", "type": "string", "name": "featureSetId"},
{"doc": "", "type": "string", "name": "referenceName"}, {"default": 0,
"doc": "", "type": "long", "name": "start"}, {"doc": "", "type":
"long", "name": "end"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "term"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceVersion"}]}, "name":
"featureType"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "Attributes", "fields": [{"default": {}, "type": {"values":
{"items": ["string", {"doc": "", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}]}, "OntologyTerm"],
"type": "array"}, "type": "map"}, "name": "vals"}]}, "name":
"attributes"}], "doc": ""}, "type": "array"}, "name": "features"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "features"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'features', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.features = kwargs.get(
            'features', [])
        """
        The list of matching annotations, sorted by start position.
        Annotations which     share a start position are returned in a
        deterministic order.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.     Provide this value in a subsequent request to
        return the next page of     results. This field will be empty
        if there aren't any additional results.
        """


class SearchReadGroupSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /readgroupsets/search as
    JSON.  TODO: Factor this out to a common API patterns section. -
    If searching by a resource ID, and that resource is not found, the
    method will return a 404 HTTP status code (NOT_FOUND). - If
    searching by other attributes, e.g. name, and no matches are
    found, the method will return a 200 HTTP status code (OK) with an
    empty result list.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The dataset to search.
        """
        self.name = kwargs.get(
            'name', None)
        """
        Only return read group sets with this name (case-sensitive,
        exact match).
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReadGroupSetsResponse(SearchResponse):
    """
    This is the response from POST /readgroupsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReadGroupSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", {"doc": "", "type": "record", "name": "ReadStats",
"fields": [{"default": null, "doc": "", "type": ["null", "long"],
"name": "alignedReadCount"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "unalignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "baseCount"}]}], "name":
"stats"}, {"default": [], "doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "ReadGroup", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"doc": "", "type": "record", "name": "Experiment", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"}, {"doc":
"", "type": "string", "name": "createDateTime"}, {"doc": "", "type":
"string", "name": "updateDateTime"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "runTime"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}], "name": "experiment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "predictedInsertSize"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "created"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "Program", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}]}, "type": "array"}, "name":
"readGroups"}], "doc": ""}, "type": "array"}, "name":
"readGroupSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'readGroupSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.readGroupSets = kwargs.get(
            'readGroupSets', [])
        """
        The list of matching read group sets.
        """


class SearchReadsRequest(SearchRequest):
    """
    This request maps to the body of POST /reads/search as JSON.  If a
    reference is specified, all queried ReadGroups must be aligned to
    ReferenceSets containing that same Reference. If no reference is
    specified, all queried ReadGroups must be aligned to the same
    ReferenceSet.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsRequest", "fields": [{"doc": "", "type": {"items":
"string", "type": "array"}, "name": "readGroupIds"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceId"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"start"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "end"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "readGroupIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
        'start'
    ]

    def __init__(self, **kwargs):
        self.end = kwargs.get(
            'end', None)
        """
        The end position (0-based, exclusive) of this query.   If a
        reference is specified, this defaults to the   reference's
        length.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.readGroupIds = kwargs.get(
            'readGroupIds', None)
        """
        The ReadGroups to search. At least one id must be specified.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        The reference to query. Leaving blank returns results from all
        references, including unmapped reads - this could be very
        large.
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position (0-based) of this query.   If a reference
        is specified, this defaults to 0.   Genomic positions are non-
        negative integers less than reference length.   Requests
        spanning the join of circular genomes are represented as   two
        requests one on each side of the join (position 0).
        """


class SearchReadsResponse(SearchResponse):
    """
    This is the response from POST /reads/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentName"}, {"default":
null, "doc": "", "type": ["null", "boolean"], "name":
"improperPlacement"}, {"default": null, "doc": "", "type": ["null",
"boolean"], "name": "duplicateFragment"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "numberReads"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "fragmentLength"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"readNumber"}, {"default": null, "doc": "", "type": ["null",
"boolean"], "name": "failedVendorQualityChecks"}, {"default": null,
"doc": "", "type": ["null", {"doc": "", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"doc": "", "type": "string",
"name": "referenceName"}, {"doc": "", "type": "long", "name":
"position"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}]}], "name": "alignment"}, {"default": null,
"doc": "", "type": ["null", "boolean"], "name": "secondaryAlignment"},
{"default": null, "doc": "", "type": ["null", "boolean"], "name":
"supplementaryAlignment"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "alignedSequence"}, {"default": [], "doc":
"", "type": {"items": "int", "type": "array"}, "name":
"alignedQuality"}, {"default": null, "doc": "", "type": ["null",
"Position"], "name": "nextMatePosition"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"alignments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignments', 'nextPageToken'
    ]

    def __init__(self, **kwargs):
        self.alignments = kwargs.get(
            'alignments', [])
        """
        The list of matching alignment records, sorted by position.
        Unmapped reads, which have no position, are returned last.
        """
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """


class SearchReferenceSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /referencesets/search as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "md5checksum"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "accession"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"assemblyId"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'assemblyId', 'md5checksum', 'pageSize',
        'pageToken'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        """
        If not null, return the reference sets for which the accession
        matches this string (case-sensitive, exact match).
        """
        self.assemblyId = kwargs.get(
            'assemblyId', None)
        """
        If not null, return the reference sets for which the
        assemblyId   matches this string (case-sensitive, exact
        match).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        If not null, return the reference sets for which the
        md5checksum matches this string (case-sensitive, exact match).
        See ReferenceSet::md5checksum for details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchReferenceSetsResponse(SearchResponse):
    """
    This is the response from POST /referencesets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReferenceSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}, "type": "array"}, "name":
"referenceSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'referenceSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.referenceSets = kwargs.get(
            'referenceSets', [])
        """
        The list of matching reference sets.
        """


class SearchReferencesRequest(SearchRequest):
    """
    This request maps to the body of POST /references/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesRequest", "fields": [{"doc": "", "type": "string",
"name": "referenceSetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "md5checksum"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "accession"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "pageSize"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accession', 'md5checksum', 'pageSize', 'pageToken',
        'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.accession = kwargs.get(
            'accession', None)
        """
        If not null, return the references for which the accession
        matches this string (case-sensitive, exact match).
        """
        self.md5checksum = kwargs.get(
            'md5checksum', None)
        """
        If not null, return the references for which the   md5checksum
        matches this string (case-sensitive, exact match).   See
        ReferenceSet::md5checksum for details.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ReferenceSet to search.
        """


class SearchReferencesResponse(SearchResponse):
    """
    This is the response from POST /references/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Reference", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "long", "name": "length"}, {"doc": "",
"type": "string", "name": "md5checksum"}, {"doc": "", "type":
"string", "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "sourceAccessions"},
{"default": false, "doc": "", "type": "boolean", "name": "isDerived"},
{"default": null, "doc": "", "type": ["null", "float"], "name":
"sourceDivergence"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "ncbiTaxonId"}], "doc": ""}, "type": "array"}, "name":
"references"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'references'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.references = kwargs.get(
            'references', [])
        """
        The list of matching references.
        """


class SearchVariantAnnotationSetsRequest(SearchRequest):
    """
    This request maps to the body of POST
    /variantannotationsets/search as JSON
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantAnnotationSetsRequest", "fields": [{"doc": "", "type":
"string", "name": "variantSetId"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        Required. The VariantSet to search.
        """


class SearchVariantAnnotationSetsResponse(SearchResponse):
    """
    This is the response from POST /variantannotationsets/search
    expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantAnnotationSetsResponse", "fields": [{"default": [],
"doc": "", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "VariantAnnotationSet", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"variantSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "Analysis", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "type": ["null", "string"], "name":
"name"}, {"default": null, "type": ["null", "string"], "name":
"description"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "createDateTime"}, {"doc": "", "type": "string",
"name": "updateDateTime"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "type"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "software"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}, "name":
"analysis"}], "doc": ""}, "type": "array"}, "name":
"variantAnnotationSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantAnnotationSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantAnnotationSets': VariantAnnotationSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantAnnotationSets': VariantAnnotationSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantAnnotationSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variantAnnotationSets = kwargs.get(
            'variantAnnotationSets', [])
        """
        The list of matching variant annotation sets.
        """


class SearchVariantAnnotationsRequest(SearchRequest):
    """
    This request maps to the body of POST /variantannotations/search
    as JSON
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantAnnotationsRequest", "fields": [{"doc": "", "type":
"string", "name": "variantAnnotationSetId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "referenceId"},
{"doc": "", "type": "long", "name": "start"}, {"doc": "", "type":
"long", "name": "end"}, {"default": null, "doc": "", "type": ["null",
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "term"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sourceName"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceVersion"}], "doc": ""}, "type":
"array"}], "name": "effects"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "start",
        "variantAnnotationSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'effects', 'end', 'pageSize', 'pageToken', 'referenceId',
        'referenceName', 'start', 'variantAnnotationSetId'
    ]

    def __init__(self, **kwargs):
        self.effects = kwargs.get(
            'effects', None)
        """
        This filter allows variant, transcript combinations to be
        extracted by effect   type(s).   Only return variant
        annotations including any of these effects and only return
        transcript effects including any of these effects. Exact
        matching across all   fields of the Sequence Ontology
        OntologyTerm is required.   (A transcript effect may have
        multiple SO effects which will all be reported.)   If null,
        return all variant annotations.
        """
        self.end = kwargs.get(
            'end', None)
        """
        Required if referenceName or referenceId supplied.   The end
        of the window (0-based, exclusive) for which variants with
        overlapping reference alleles should be returned.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceId = kwargs.get(
            'referenceId', None)
        """
        Only return variants with reference alleles on the reference
        with this   ID. One of this field or referenceName or features
        is required.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Only return variants with reference alleles on the reference
        with this   name. One of this field or referenceId or features
        is required.   (case-sensitive, exact match)
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required if referenceName or referenceId supplied.   The
        beginning of the window (0-based, inclusive) for which
        variants with   overlapping reference alleles should be
        returned.   Genomic positions are non-negative integers less
        than reference length.   Requests spanning the join of
        circular genomes are represented as   two requests one on each
        side of the join (position 0).
        """
        self.variantAnnotationSetId = kwargs.get(
            'variantAnnotationSetId', None)
        """
        Required. The ID of the variant annotation set to search over.
        """


class SearchVariantAnnotationsResponse(SearchResponse):
    """
    This is the response from POST /variantannotations/search
    expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantAnnotationsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "VariantAnnotation", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"doc": "", "type": "string", "name":
"variantId"}, {"doc": "", "type": "string", "name":
"variantAnnotationSetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "createDateTime"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"TranscriptEffect", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "featureId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"alternateBases"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "term"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceName"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "sourceVersion"}]}, "type":
"array"}, "name": "effects"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "HGVSAnnotation", "fields": [{"default": null,
"type": ["null", "string"], "name": "genomic"}, {"default": null,
"type": ["null", "string"], "name": "transcript"}, {"default": null,
"type": ["null", "string"], "name": "protein"}]}, "name":
"hgvsAnnotation"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "AlleleLocation", "fields":
[{"doc": "", "type": "int", "name": "start"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceSequence"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"alternateSequence"}]}], "name": "cDNALocation"}, {"default": null,
"type": ["null", "AlleleLocation"], "name": "CDSLocation"},
{"default": null, "doc": "", "type": ["null", "AlleleLocation"],
"name": "proteinLocation"}, {"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "AnalysisResult", "fields": [{"doc": "",
"type": "string", "name": "analysisId"}, {"doc": "", "type": ["null",
"string"], "name": "result"}, {"doc": "", "type": ["null", "int"],
"name": "score"}]}, "type": "array"}, "name": "analysisResults"}]},
"type": "array"}, "name": "transcriptEffects"}, {"default": {}, "doc":
"", "type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"variantAnnotations"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantAnnotations"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantAnnotations': VariantAnnotation,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantAnnotations': VariantAnnotation,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantAnnotations'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variantAnnotations = kwargs.get(
            'variantAnnotations', [])
        """
        The list of matching variant annotations.
        """


class SearchVariantSetsRequest(SearchRequest):
    """
    This request maps to the body of POST /variantsets/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsRequest", "fields": [{"doc": "", "type": "string",
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'pageSize', 'pageToken'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The Dataset to search.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """


class SearchVariantSetsResponse(SearchResponse):
    """
    This is the response from POST /variantsets/search expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "VariantSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": "string", "name": "datasetId"},
{"doc": "", "type": "string", "name": "referenceSetId"}, {"default":
[], "doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}, "type": "array"}, "name": "variantSets"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantSets'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variantSets = kwargs.get(
            'variantSets', [])
        """
        The list of matching variant sets.
        """


class SearchVariantsRequest(SearchRequest):
    """
    This request maps to the body of POST /variants/search as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsRequest", "fields": [{"doc": "", "type": "string",
"name": "variantSetId"}, {"default": null, "doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "callSetIds"}, {"doc":
"", "type": "string", "name": "referenceName"}, {"doc": "", "type":
"long", "name": "start"}, {"doc": "", "type": "long", "name": "end"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "referenceName",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'end', 'pageSize', 'pageToken', 'referenceName',
        'start', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.callSetIds = kwargs.get(
            'callSetIds', None)
        """
        Only return variant calls which belong to call sets with these
        IDs.   If an empty array, returns variants without any call
        objects.   If null, returns all variant calls.
        """
        self.end = kwargs.get(
            'end', None)
        """
        Required. The end of the window (0-based, exclusive) for which
        overlapping   variants should be returned.
        """
        self.pageSize = kwargs.get(
            'pageSize', None)
        """
        Specifies the maximum number of results to return in a single
        page.   If unspecified, a system default will be used.
        """
        self.pageToken = kwargs.get(
            'pageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   To get the next page of results, set this
        parameter to the value of   nextPageToken from the previous
        response.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        Required. Only return variants on this reference.
        """
        self.start = kwargs.get(
            'start', None)
        """
        Required. The beginning of the window (0-based, inclusive) for
        which overlapping variants should be returned.   Genomic
        positions are non-negative integers less than reference
        length.   Requests spanning the join of circular genomes are
        represented as   two requests one on each side of the join
        (position 0).
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The VariantSet to search.
        """


class SearchVariantsResponse(SearchResponse):
    """
    This is the response from POST /variants/search expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Variant", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "names"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"doc": "", "type":
"string", "name": "referenceName"}, {"doc": "", "type": "long",
"name": "start"}, {"doc": "", "type": "long", "name": "end"}, {"doc":
"", "type": "string", "name": "referenceBases"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"alternateBases"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Call", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "callSetId"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "genotype"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "phaseset"}, {"default": [], "doc": "", "type":
{"items": "double", "type": "array"}, "name": "genotypeLikelihood"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}, "type": "array"},
"name": "calls"}], "doc": ""}, "type": "array"}, "name": "variants"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variants'
    ]

    def __init__(self, **kwargs):
        self.nextPageToken = kwargs.get(
            'nextPageToken', None)
        """
        The continuation token, which is used to page through large
        result sets.   Provide this value in a subsequent request to
        return the next page of   results. This field will be empty if
        there aren't any additional results.
        """
        self.variants = kwargs.get(
            'variants', [])
        """
        The list of matching variants.   If the callSetId field on the
        returned calls is not present,   the ordering of the call sets
        from a SearchCallSetsRequest   over the parent VariantSet is
        guaranteed to match the ordering   of the calls on each
        Variant. The number of results will also be   the same.
        """


class Strand(object):
    """
    Indicates the DNA strand associate for some data item. *
    NEG_STRAND: The negative (-) strand. * POS_STRAND:  The postive
    (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"


class TranscriptEffect(ProtocolElement):
    """
    A transcript effect record is a set of information describing the
    effect of an allele on a transcript
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"TranscriptEffect", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "featureId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"alternateBases"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "term"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceName"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "sourceVersion"}]}, "type":
"array"}, "name": "effects"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "HGVSAnnotation", "fields": [{"default": null,
"type": ["null", "string"], "name": "genomic"}, {"default": null,
"type": ["null", "string"], "name": "transcript"}, {"default": null,
"type": ["null", "string"], "name": "protein"}]}, "name":
"hgvsAnnotation"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "AlleleLocation", "fields":
[{"doc": "", "type": "int", "name": "start"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceSequence"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"alternateSequence"}]}], "name": "cDNALocation"}, {"default": null,
"type": ["null", "AlleleLocation"], "name": "CDSLocation"},
{"default": null, "doc": "", "type": ["null", "AlleleLocation"],
"name": "proteinLocation"}, {"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "AnalysisResult", "fields": [{"doc": "",
"type": "string", "name": "analysisId"}, {"doc": "", "type": ["null",
"string"], "name": "result"}, {"doc": "", "type": ["null", "int"],
"name": "score"}]}, "type": "array"}, "name": "analysisResults"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisResults",
        "effects",
        "featureId",
        "hgvsAnnotation",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'CDSLocation': AlleleLocation,
            'analysisResults': AnalysisResult,
            'cDNALocation': AlleleLocation,
            'effects': OntologyTerm,
            'hgvsAnnotation': HGVSAnnotation,
            'proteinLocation': AlleleLocation,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'CDSLocation': AlleleLocation,
            'analysisResults': AnalysisResult,
            'cDNALocation': AlleleLocation,
            'effects': OntologyTerm,
            'hgvsAnnotation': HGVSAnnotation,
            'proteinLocation': AlleleLocation,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'CDSLocation', 'alternateBases', 'analysisResults',
        'cDNALocation', 'effects', 'featureId', 'hgvsAnnotation',
        'id', 'proteinLocation'
    ]

    def __init__(self, **kwargs):
        self.CDSLocation = kwargs.get(
            'CDSLocation', None)
        self.alternateBases = kwargs.get(
            'alternateBases', None)
        """
        Alternate allele - a variant may have more than one alternate
        allele,   each of which will have distinct annotation.
        """
        self.analysisResults = kwargs.get(
            'analysisResults', None)
        """
        Output from prediction packages such as SIFT
        """
        self.cDNALocation = kwargs.get(
            'cDNALocation', None)
        """
        Change relative to cDNA
        """
        self.effects = kwargs.get(
            'effects', None)
        """
        Effect of variant on this feature
        """
        self.featureId = kwargs.get(
            'featureId', None)
        """
        The id of the transcript feature the annotation is relative to
        """
        self.hgvsAnnotation = kwargs.get(
            'hgvsAnnotation', None)
        """
        Human Genome Variation Society variant descriptions
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of the transcript effect record
        """
        self.proteinLocation = kwargs.get(
            'proteinLocation', None)
        """
        Change relative to protein
        """


class Variant(ProtocolElement):
    """
    A Variant represents a change in DNA sequence relative to some
    reference. For example, a variant could represent a SNP or an
    insertion. Variants belong to a VariantSet. This is equivalent to
    a row in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Variant",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "names"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"doc": "", "type": "string", "name":
"referenceName"}, {"doc": "", "type": "long", "name": "start"},
{"doc": "", "type": "long", "name": "end"}, {"doc": "", "type":
"string", "name": "referenceBases"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name":
"alternateBases"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Call", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "callSetId"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "genotype"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "phaseset"}, {"default": [], "doc": "", "type":
{"items": "double", "type": "array"}, "name": "genotypeLikelihood"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}, "type": "array"},
"name": "calls"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "id",
        "referenceBases",
        "referenceName",
        "start",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateBases', 'calls', 'created', 'end', 'id', 'info',
        'names', 'referenceBases', 'referenceName', 'start',
        'updated', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.alternateBases = kwargs.get(
            'alternateBases', [])
        """
        The bases that appear instead of the reference bases. Multiple
        alternate   alleles are possible.
        """
        self.calls = kwargs.get(
            'calls', [])
        """
        The variant calls for this particular variant. Each one
        represents the   determination of genotype with respect to
        this variant. Calls in this array   are implicitly associated
        with this Variant.
        """
        self.created = kwargs.get(
            'created', None)
        """
        The date this variant was created in milliseconds from the
        epoch.
        """
        self.end = kwargs.get(
            'end', None)
        """
        The end position (exclusive), resulting in [start, end)
        closed-open interval.   This is typically calculated by start
        + referenceBases.length.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant ID.
        """
        self.info = kwargs.get(
            'info', {})
        """
        A map of additional variant information.
        """
        self.names = kwargs.get(
            'names', [])
        """
        Names for the variant, for example a RefSNP ID.
        """
        self.referenceBases = kwargs.get(
            'referenceBases', None)
        """
        The reference bases for this variant. They start at the given
        start position.
        """
        self.referenceName = kwargs.get(
            'referenceName', None)
        """
        The reference on which this variant occurs.   (e.g. chr20 or
        X)
        """
        self.start = kwargs.get(
            'start', None)
        """
        The start position at which this variant occurs (0-based).
        This corresponds to the first base of the string of reference
        bases.   Genomic positions are non-negative integers less than
        reference length.   Variants spanning the join of circular
        genomes are represented as   two variants one on each side of
        the join (position 0).
        """
        self.updated = kwargs.get(
            'updated', None)
        """
        The time at which this variant was last updated in
        milliseconds from the epoch.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The ID of the VariantSet this variant belongs to. This
        transitively defines   the ReferenceSet against which the
        Variant is to be interpreted.
        """


class VariantAnnotation(ProtocolElement):
    """
    A VariantAnnotation record represents the result of comparing a
    variant to a set of reference data.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantAnnotation", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantId"}, {"doc": "",
"type": "string", "name": "variantAnnotationSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "createDateTime"},
{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "TranscriptEffect", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"doc": "", "type": "string", "name":
"featureId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "alternateBases"}, {"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "OntologyTerm", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "term"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "sourceName"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceVersion"}]},
"type": "array"}, "name": "effects"}, {"doc": "", "type": {"doc": "",
"type": "record", "name": "HGVSAnnotation", "fields": [{"default":
null, "type": ["null", "string"], "name": "genomic"}, {"default":
null, "type": ["null", "string"], "name": "transcript"}, {"default":
null, "type": ["null", "string"], "name": "protein"}]}, "name":
"hgvsAnnotation"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "AlleleLocation", "fields":
[{"doc": "", "type": "int", "name": "start"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceSequence"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"alternateSequence"}]}], "name": "cDNALocation"}, {"default": null,
"type": ["null", "AlleleLocation"], "name": "CDSLocation"},
{"default": null, "doc": "", "type": ["null", "AlleleLocation"],
"name": "proteinLocation"}, {"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "AnalysisResult", "fields": [{"doc": "",
"type": "string", "name": "analysisId"}, {"doc": "", "type": ["null",
"string"], "name": "result"}, {"doc": "", "type": ["null", "int"],
"name": "score"}]}, "type": "array"}, "name": "analysisResults"}]},
"type": "array"}, "name": "transcriptEffects"}, {"default": {}, "doc":
"", "type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "variantAnnotationSetId",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'transcriptEffects': TranscriptEffect,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'transcriptEffects': TranscriptEffect,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'createDateTime', 'id', 'info', 'transcriptEffects',
        'variantAnnotationSetId', 'variantId'
    ]

    def __init__(self, **kwargs):
        self.createDateTime = kwargs.get(
            'createDateTime', None)
        """
        The :ref:ISO 8601 <metadata_date_time> time at which this
        record was created.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of this VariantAnnotation.
        """
        self.info = kwargs.get(
            'info', {})
        """
        Additional annotation data in key-value pairs.
        """
        self.transcriptEffects = kwargs.get(
            'transcriptEffects', [])
        """
        The transcript effect annotation for the alleles of this
        variant. Each one   represents the effect of a single allele
        on a single transcript.
        """
        self.variantAnnotationSetId = kwargs.get(
            'variantAnnotationSetId', None)
        """
        The ID of the variant annotation set this record belongs to.
        """
        self.variantId = kwargs.get(
            'variantId', None)
        """
        The variant ID.
        """


class VariantAnnotationSet(ProtocolElement):
    """
    A VariantAnnotationSet record groups VariantAnnotation records. It
    is derived from a VariantSet and holds information describing the
    software and reference data used in the annotation.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantAnnotationSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"Analysis", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "type": ["null", "string"], "name": "name"},
{"default": null, "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"createDateTime"}, {"doc": "", "type": "string", "name":
"updateDateTime"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "type"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "software"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}]}, "name": "analysis"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysis",
        "id",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analysis': Analysis,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analysis': Analysis,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysis', 'id', 'name', 'variantSetId'
    ]

    def __init__(self, **kwargs):
        self.analysis = kwargs.get(
            'analysis', None)
        """
        Analysis details. It is essential to supply versions for all
        software and   reference data used.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The ID of the variant annotation set record
        """
        self.name = kwargs.get(
            'name', None)
        """
        The variant annotation set name.
        """
        self.variantSetId = kwargs.get(
            'variantSetId', None)
        """
        The ID of the variant set to which this annotation set belongs
        """


class VariantSet(ProtocolElement):
    """
    A VariantSet is a collection of variants and variant calls
    intended to be analyzed together.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"doc": "", "type": "string", "name": "datasetId"}, {"doc":
"", "type": "string", "name": "referenceSetId"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'metadata', 'name', 'referenceSetId'
    ]

    def __init__(self, **kwargs):
        self.datasetId = kwargs.get(
            'datasetId', None)
        """
        The ID of the dataset this variant set belongs to.
        """
        self.id = kwargs.get(
            'id', None)
        """
        The variant set ID.
        """
        self.metadata = kwargs.get(
            'metadata', [])
        """
        Optional metadata associated with this variant set.   This
        array can be used to store information about the variant set,
        such as information found   in VCF header fields, that isn't
        already available in first class fields such as "name".
        """
        self.name = kwargs.get(
            'name', None)
        """
        The variant set name.
        """
        self.referenceSetId = kwargs.get(
            'referenceSetId', None)
        """
        The ID of the reference set that describes the sequences used
        by the variants in this set.
        """


class VariantSetMetadata(ProtocolElement):
    """
    Optional metadata associated with a variant set.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'key', 'number', 'type', 'value'
    ]

    def __init__(self, **kwargs):
        self.description = kwargs.get(
            'description', None)
        """
        A textual description of this metadata.
        """
        self.id = kwargs.get(
            'id', None)
        """
        User-provided ID field, not enforced by this API.   Two or
        more pieces of structured metadata with identical   id and key
        fields are considered equivalent.   FIXME: If it's not
        enforced, then why can't it be null?
        """
        self.info = kwargs.get(
            'info', {})
        """
        Remaining structured metadata key-value pairs.
        """
        self.key = kwargs.get(
            'key', None)
        """
        The top-level key.
        """
        self.number = kwargs.get(
            'number', None)
        """
        The number of values that can be included in a field described
        by this   metadata.
        """
        self.type = kwargs.get(
            'type', None)
        """
        The type of data.
        """
        self.value = kwargs.get(
            'value', None)
        """
        The value field for simple metadata.
        """


class ReadCounts(ProtocolElement):
    """
Details of the read counts.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name": "ReadCounts",
"fields": [{"doc": "", "type": "string", "name": "analysisId"},
{"doc": "", "type": "int", "name": "totalReadCount"}, {"doc": "",
"type": "int", "name": "uniqueCount"}, {"doc": "", "type": "int",
"name": "multiCount"}, {"doc": "", "type": "int", "name":
"uniqueSpliceCount"}, {"doc": "", "type": "int", "name":
"multiSpliceCount"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "analysisId",
        "multiCount",
        "multiSpliceCount",
        "totalReadCount",
        "uniqueCount",
        "uniqueSpliceCount",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['analysisId', 'multiCount', 'multiSpliceCount',
                 'totalReadCount', 'uniqueCount',
                 'uniqueSpliceCount']

    def __init__(self):
        self.analysisId = None
        self.multiCount = None
        self.multiSpliceCount = None
        self.totalReadCount = None
        self.uniqueCount = None
        self.uniqueSpliceCount = None


class SearchExpressionLevelRequest(SearchRequest):
    """
This request maps to the body of 'POST /expressionlevel/search'
as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchExpressionLevelRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "expressionLevelId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"featureGroupId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "rnaQuantificationId"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = [
        'expressionLevelId', 'featureGroupId', 'pageSize', 'pageToken',
        'rnaQuantificationId']

    def __init__(self):
        self.expressionLevelId = None
        self.featureGroupId = None
        self.pageSize = None
        self.pageToken = None
        self.rnaQuantificationId = None


class SearchExpressionLevelResponse(SearchResponse):
    """
This is the response from 'POST /expressionlevel/search' expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchExpressionLevelResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"ExpressionLevel", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "featureGroupId"},
{"doc": "", "type": "string", "name": "annotationId"}, {"doc": "",
"type": "float", "name": "rawReadCount"}, {"default": null, "doc": "",
"type": ["null", "float"], "name": "expression"}, {"default": false,
"doc": "", "type": ["null", "boolean"], "name": "isNormalized"},
{"default": null, "doc": "", "type": ["null", {"symbols": ["FPKM",
"RPM"], "doc": "", "type": "enum", "name": "ExpressionUnits"}],
"name": "units"}, {"default": null, "doc": "", "type": ["null",
"float"], "name": "score"}]}, "type": "array"}, "name":
"expressionLevel"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "expressionLevel"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'expressionLevel': ExpressionLevel,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'expressionLevel': ExpressionLevel,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['expressionLevel', 'nextPageToken']

    def __init__(self):
        self.expressionLevel = []
        self.nextPageToken = None


class SearchRnaQuantificationRequest(SearchRequest):
    """
This request maps to the body of 'POST /rnaquantification/search'
as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchRnaQuantificationRequest", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "rnaQuantificationId"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['rnaQuantificationId', 'pageSize', 'pageToken']

    def __init__(self):
        self.rnaQuantificationId = None
        self.pageSize = None
        self.pageToken = None


class SearchRnaQuantificationResponse(SearchResponse):
    """
This is the response from 'POST /rnaquantification/search' expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchRnaQuantificationResponse", "fields": [{"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"RnaQuantification", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"doc": "", "type":
"string", "name": "readGroupId"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "annotationIds"}]},
"type": "array"}, "name": "rnaQuantification"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "rnaQuantification"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'rnaQuantification': RnaQuantification,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'rnaQuantification': RnaQuantification,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['rnaQuantification', 'nextPageToken']

    def __init__(self):
        self.rnaQuantification = []
        self.nextPageToken = None


class SearchFeatureGroupRequest(SearchRequest):
    """
This request maps to the body of 'POST /featuregroup/search'
as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchFeatureGroupRequest", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "featureGroupId"},
{"default": null, "doc": "", "type": ["null", "float"], "name":
"threshold"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return embeddedTypes[fieldName]

    __slots__ = ['featureGroupId', 'threshold','pageSize', 'pageToken']

    def __init__(self):
        self.featureGroupId = None
        threshold = None
        self.pageSize = None
        self.pageToken = None


class SearchFeatureGroupResponse(SearchResponse):
    """
This is the response from 'POST /featuregroup/search' expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh", "type": "record", "name":
"SearchFeatureGroupResponse", "fields": [{"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"FeatureGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "analysisId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type": "map"},
"name": "info"}]}, "type": "array"}, "name": "featureGroup"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "featureGroup"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureGroup': FeatureGroup,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'featureGroup': FeatureGroup,
        }
        return embeddedTypes[fieldName]

    __slots__ = ['featureGroup', 'nextPageToken']

    def __init__(self):
        self.featureGroup = []
        self.nextPageToken = None


postMethods = \
    [('/callsets/search',
      SearchCallSetsRequest,
      SearchCallSetsResponse),
     ('/datasets/search',
      SearchDatasetsRequest,
      SearchDatasetsResponse),
     ('/features/search',
      SearchFeaturesRequest,
      SearchFeaturesResponse),
     ('/featuresets/search',
      SearchFeatureSetsRequest,
      SearchFeatureSetsResponse),
     ('/readgroupsets/search',
      SearchReadGroupSetsRequest,
      SearchReadGroupSetsResponse),
     ('/reads/search',
      SearchReadsRequest,
      SearchReadsResponse),
     ('/references/search',
      SearchReferencesRequest,
      SearchReferencesResponse),
     ('/referencesets/search',
      SearchReferenceSetsRequest,
      SearchReferenceSetsResponse),
     ('/variantannotations/search',
      SearchVariantAnnotationsRequest,
      SearchVariantAnnotationsResponse),
     ('/variantannotationsets/search',
      SearchVariantAnnotationSetsRequest,
      SearchVariantAnnotationSetsResponse),
     ('/variants/search',
      SearchVariantsRequest,
      SearchVariantsResponse),
     ('/variantsets/search',
      SearchVariantSetsRequest,
      SearchVariantSetsResponse),
     ('/expressionlevel/search',
      SearchExpressionLevelRequest,
      SearchExpressionLevelResponse),
     ('/rnaquantification/search',
      SearchRnaQuantificationRequest,
      SearchRnaQuantificationResponse)]
